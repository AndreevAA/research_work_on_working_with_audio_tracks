<!-- Copy and paste the converted output. -->

<!-----
NEW: Check the "Suppress top comment" option to remove this info from the output.

Conversion time: 5.476 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β31
* Thu Nov 18 2021 06:17:36 GMT-0800 (PST)
* Source doc: НИР_Андреев_Александр_ИУ7-54Б_2021
* Tables are currently converted to HTML tables.
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!


WARNING:
You have 4 H1 headings. You may want to use the "H1 -> H2" option to demote all headings by one level.

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 1; ALERTS: 15.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>



<table>
  <tr>
   <td>
   </td>
   <td><strong>Министерство науки и высшего образования Российской Федерации</strong>
<p>
<strong>Федеральное государственное бюджетное образовательное учреждение </strong>
<p>
<strong>высшего образования</strong>
<p>
<strong>«Московский государственный технический университет</strong>
<p>
<strong>имени Н.Э. Баумана</strong>
<p>
<strong>(национальный исследовательский университет)»</strong>
<p>
<strong>(МГТУ им. Н.Э. Баумана)</strong>
   </td>
  </tr>
</table>


ФАКУЛЬТЕТ ИУ, Информатика и системы управления

КАФЕДРА ИУ7, Программное обеспечение ЭВМ и информационные технологии 

**Научно-исследовательская работа**

**_НА ТЕМУ:_**

**_Исследование звука: Удаление шумов и разделение аудиодорожки на несколько говорящих._**

Студент           ИУ7-54Б				**_________________  ____<span style="text-decoration:underline;">А.А. Андреев</span>___**


    (Группа)					  (Подпись, дата)                            (И.О.Фамилия)            

Руководитель НИР	 				**_________________  __<span style="text-decoration:underline;">М. С. Шаповалова</span>_ **

<p style="text-align: right">
(Подпись, дата)                             (И.О.Фамилия)            </p>


Консультант 						**_________________  ____________________ **

<p style="text-align: right">
(Подпись, дата)                             (И.О.Фамилия)            </p>


_2021 г._

**Оглавление**


[TOC]





# Введение.


Рендер (Рендеринг) — это процесс создания финального изображения или последовательности из изображений на основе двухмерных или трехмерных данных. Данный процесс происходит с использованием компьютерных программ и зачастую сопровождается трудными техническими вычислениями, которые ложатся на вычислительные мощности компьютера или на отдельные его комплектующие части. 


Процесс рендеринга так или иначе присутствует в разных сферах профессиональной деятельности, будь то киноиндустрия, индустрия видеоигр или же видеоблогинг. Зачастую, рендер является последним или предпоследним этапом в работе над проектом, после чего работа считается завершенной или же нуждается в небольшой постобработке. Также стоит отметить, что нередко рендером называют не сам процесс рендеринга, а скорее уже завершенный этап данного процесса или его итоговый результат. 


Если мы говорим о задаче рендеринга изображения, то чаще всего имеем в виду рендеринг в трёхмерной графике, так как это задача является востребованнее всего в этой сфере. Это связано с тем, что как такового трехмерного измерения в компьютерной графике не существует и работа ведется с двухмерным изображением. 


Цель данной работы – реализовать построение трехмерной сцены при моделировании программы детского конструктора.


Чтобы достигнуть поставленной цели, требуется решить следующие задачи:


1) описать структуру трехмерной сцены, включая объекты, из которых состоит сцена


2) выбрать алгоритмов из существующих трехмерной графики, которые позволят визуализировать трехмерную сцену;


3) реализовать данные алгоритмы для создания трехмерной сцены;


4) разработать программное обеспечение, которое позволит отобразить трехмерную сцену и визуализировать модели детского конструктора.



1. Аналитическая часть

	В данной части производится анализ и сравнение методов и алгоритмов предметной области, необходимых для выполнения поставленной задачи. 



    1. Постановка задачи

	Разработать программу моделирования склейки 3D-объектов детского конструктора Лего. Программа должна поддерживать следующие функции: вращение камеры вокруг сцены; добавление до двух источников света; добавление шаблонных заранее заданных, блоков конструктора, доступных в программе; перемещение выбранной фигуры конструктора из списка загруженных объектов в трех плоскостях; удаление любого блока. Каждый блок конструктора Лего должен обладать строгой жесткостью поверхности во избежание наложения объекта при перемещении. Размеры сцены задается пользователем и не может превышать 1920х1080 Размеры сцены пользователь задает при запуске программы. Можно выделить следующие задачи: 



* реализация процедуры чтения из файлов формата txt; 
* реализация создания объектов сцены; 
* реализация алгоритма z-буфера; 
* реализация метода тонирования Гуро для закраски объекта; 
* реализация камеры и источника света; 
* реализация пользовательского интерфейса. 
* реализация перемещения объекта сцены. 
* реализация поворота объекта сцены.
* реализация удаления объектов сцены.
    2. Алгоритм Брезенхема

Алгоритм Брезенхема построения отрезков выбирает оптимальные растровые координаты для представления отрезка.

Данный алгоритм позволяет получить приближение идеальной прямой точками растровой сетки. 

Основная идея алгоритма базируется на понятии ошибки, где ошибка - это расстояние между действительным положением отрезка и ближайшими координатами сетки. 

В данном алгоритме проверяется принадлежность проекции к оси x или y. На какую ось проекция будет больше, на ту ось и смещается пиксель. По другой оси смещение на один пиксель происходить лишь в том случае, когда линия отклонилось от оси более чем на половину пикселя. 

Преимущество: \
	• высокая скорость растрирования вектора. 

Недостатки: 

	• при низком разрешении экрана наблюдается эффект  ступенчатости;

	• округление значений: действительные величины преобразуются в ближайшие целые числа.



    3. Удаление невидимых линий

Одна из самых сложных задач в компьютерной графике - это удаление невидимых линий и поверхностей. На данный момент не существует алгоритма, сочетающего в себе быструю скорость работы и высокую детализацию (расчет тени, прозрачности, фактуры, отражения и преломления света)

Алгоритмы удаления невидимых линий и поверхностей делятся на два вида: 

1. работающие в пространстве изображения;

2. работающие в объектном пространстве. 

В подходе работы в **пространстве изображения** находятся ближайшие точки сцены к наблюдателю и отображаются. В нем не требуется высокой точности вычислений, поэтому сложности таких алгоритмов не превышает O(c ∗ n), где c - число пикселей, n - количество объектов. Единственное ограничения - разрешающая способностью экрана. 

В подходе работы в **объектном пространстве **действия происходят в физической системе координат, в ней описаны данные объекты. Сложность таких алгоритмов в среднем для n объектов O(n^2). Такой алгоритм дает достаточно точные результаты, не зависящего от разрешений экрана, именно из-за этого возникает низкая скорость работы.

В рамках курсового проекта необходимо было выбрать такой алгоритм, который бы быстро удалял задние линии и поверхности, поэтому выбор осуществлялся между следующими алгоритмами: 

1. алгоритм художника; 

2. алгоритм Z-буфера; 

3. алгоритм A-буфера.



        1. Алгоритм художника

Алгоритм художника является простейшим вариантом решения задачи об удалении невидимых линий и граней в компьютерной графике. 

Название «алгоритм художника» относится к технике, используемой многими живописцами: сначала рисуются наиболее удаленные части сцены, потом части которые ближе. Постепенно ближние части начинают перекрывать отдаленные части более удалённых объектов. Задача программиста при реализации алгоритма художника — отсортировать все полигоны по удаленности от наблюдателя и начать выводить, начиная с более дальних.  

Главным недостатком данного алгоритма является неправильное вычислений задних граней при определенных сценариях: когда один многоугольник является относительно одной фигуры неэкранируемым, а относительно другой является экранируемым. Данную проблему можно наблюдать на рисунке 1.4.1.1. 

     Также этот алгоритм работает медленно, из-за отрисовки ненужных задних граней, которые по итогу будут закрашены ближней гранью к наблюдателю. И если задних граней будет много, то данный алгоритм будет весьма трудозатратным. 



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")


Рис. 1.4.1.1: Ошибочный вариант расположения фигур для алгоритма художника



        2. Алгоритм Z-буфера

Алгоритм Z-буфера заключается в том, что помимо буфера кадра: место, где содержится информация о цвете для каждого пикселя в пространстве изображения, у нас также будет z-буфер, в котором будет хранится координата z, другими словами, глубина, для каждого пикселя. 

Во время работы алгоритма, значение z-буфера или глубины сравнивается со значением, которое нужно занести в z-буфер. Если сравнение показывает, что новое значение расположено ближе к наблюдателю по оси z, то новый пиксел заносится в буфер кадра и z-буфер корректируется новым значением z. Визуализацию работы алгоритма можно посмотреть на рисунке 1.4.2.1. 



<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")


_Рис. 1.4.2.1: Работа алгоритма z-буфер_

Данный алгоритм является быстродейственным, из-за того, что в нем не выполняются лишние операции, как это было с отрисовкой задних граней в алгоритме художника. 

Однако, есть два существенных недостатка: первый заключается в том, что для хранения буфера кадра и z-буфера нужно выделить большой объем памяти[1]. Второй недостаток заключается в том, что пиксели в буфер кадра заносятся в произвольном порядке, поэтому появляются трудности с реализацией эффектов прозрачности или просвечивания. Второй недостаток можно не учитывать, если заранее известно, из каких материалов состоит объект. 



        3. Алгоритм А-буфера

Данный алгоритм иногда называют модификацией z-буфера. Данный алгоритм специально предназначен для осуществления эффекта усреднения по области, прозрачности и наложения полигонов. На замену z-буфера приходит буфер накопления, который помимо координаты z хранит данные о поверхности. Пример работы можно увидеть на рисунке 1.4.3.1.



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.jpg "image_tooltip")


_Рис. 1.4.3.1: Работа алгоритма а-буфер_



    4. Метод тонирования Гуро

	Метод тонирования Гуро основан на интерполяции интенсивности, данный метод подход к закраске объекта, позволяет устранить дискретность изменения интенсивности. 

Процесс закраски Гуро можно разделить на четыре этапа: 



1. вычисление нормалей ко всем полигонам; 
2. определение нормали в вершинах путем усреднения нормалей по всем полигональным граням; 
3. вычисление значений интенсивности в вершинах, используя нормали в вершинах и применяя произвольный метод закраски; 
4. закрашивание многоугольника путем линейной интерполяции значений интенсивности в вершинах (сначала вдоль каждого ребра, а затем между ребрами). 

	Интерполяция интенсивностей работает следующим образом: для всех ребер запоминается начальная интенсивность, изменение интенсивности при каждом шаге по координате y. Затем, заполнение видимого интервала производится путем интерполяции между значениями интенсивности на ребрах, ограничивающих интервал (рис. 1.5.1). 

	На рисунке 1.5.2 приведены три формулы вычисления интенсивности цвета для каждой границы строки от Ia до Ib, приведенной на рисунке 1.5.1. 



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.jpg "image_tooltip")


_Рис. 1.5.1: Интерполяция интенсивностей_



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")


_Рис. 1.5.2: Формулы вычисления интенсивности цвета_



    5. Выводы из аналитического раздела

	В данном разделе были описаны: алгоритм Брезенхема, файлы формата Wavefront obj, алгоритм художника, алгоритм z-буфера, a-буфера, метод тонировки Гуро. Также было проведено сравнение алгоритмов удаления невидимых линий и поверхностей. 



1. Конструкторская часть.

	В данном разделе будет приведена блок-схема алгоритма z-буфера. Также будет описан процесс рендера изображения. 



    6. Требования к программе

Программа должна предоставлять следующие возможности: 



* визуальное отображение сцены;
* визуальное отображение источника света;
* поворот объекта.
    7. Выбор алгоритма для удаления невидимых линий

        	Для задачи визуализации, поворота относительно его центра и перемещения трехмерного объект наиболее подходящим алгоритмом выглядит алгоритм z-буфера, потому что алгоритм a-буфера будет выполнять лишнюю работу, так как объекты сплошные, алгоритм художника и алгоритмы, работающие в трехмерном пространстве, будут затрачивать значительное время при рендеринге объекта ввиду своей трудозатратности.



    8. Процесс отрисовки изображения

	В качестве алгоритма визуализации объекта был выбран алгоритм z-буфер. Данный выбор был аргументирован в аналитической части. 

	Основные этапы работы данного алгоритма: 



1. инициализация и заполнение буфера кадра фоновым значением интенсивности цвета; 
2. инициализация и заполнение z-буфера максимальным значением z; 
3. преобразование объекта в растровую форму (порядок преобразования не имеет значения); 
4. для каждого пиксела в многоугольнике вычислить его глубину z(x, y) или расстояние по оси z. Сравнить вычисленную глубину z(x, y) со значением в zbuffer(x, y); 
5. Если значение z(x, y) будет меньше значения zbuffer(x, y), тогда заменяем значение zbuffer(x, y) на z(x, y) и вычисляем новое значение интенсивности цвета для точки с координатами (x, y, z(x, y)); 
6. в противном случае, никаких действий не выполнять. 

Процесс рендера программном модуле проходит через 4 этапа: 

	1. преобразование мировых координат к координатам сцены; \
	2. удаление невидимых линий и поверхностей при помощи алгоритма z-буфер; 

	3. вычисление интенсивности цвета для граней методом тонирования Гуро; \
	4. вывод изображения на экран. 

Пункты 2 и 3 выполняются совместно. 

Схема работы алгоритма представлена на рисунках 2.2.1 - 2.2.2. 

	 



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.jpg "image_tooltip")


_Рис. 2.2.1: Схема работы алгоритма z-буфер часть 1_



<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.jpg "image_tooltip")


_Рис. 2.2.2: Схема работы алгоритма z-буфер часть 2_



    9. Предоставляемый функционал 

	Интерфейс представляет собой некое пространство, в котором пользователь может выполнять различные преобразования с моделью. 	Можно выделить следующие возможности:  \
• выбор детали детского конструктора для рендеринга; 

• перемещение деталей детского конструктора внутри пространства; 

• вращение деталей детского конструктора внутри пространства; 



    10. Вывод 

	В данном разделе была приведена схема работы алгоритма z-буфер, была описана работа рендера изображения в целом. Также были описаны возможности пользователя. 



2. Технологическая часть.

	В данном разделе будут рассмотрены требования к разрабатываемому программному обеспечению, средства, использованные в процессе разработки для реализации поставленных задач. 



    1.  Требования к программному обеспечению

	Программное обеспечение должно реализовывать поставленную на курсовой проект задачу. В программном модуле должен присутствовать интерфейс для взаимодействия с объектом. Программа не должна аварийно завершаться, сильно нагружать процессор, а также не должна задействовать большой объем оперативной памяти. 



    2.  Выбор и обоснование языка и среды программирования.

	Для разработки данной программы применён язык Python 3, интерфейс Tkinter по следующим причинам:



* широкие возможности реализации алгоритмов;
* большое количество виджетов и их гибкость;
* удобство отладки и редактирования программы;
    3.  Использованные типы и структуры данных

	В реализованной программе использовались некоторые базовые типы и структуры данных языка Python 3, такие как integer, float, string, list, map.

Кроме того, в программе используются специально разработанные для поставленной задачи классы: 



* BaseLoader - класс, назначение которого - считывать данные из файла. \


<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")
 
* OperationData - структура, предназначенная для хранения данных, задействованных в оконном приложении; \


<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")

* Detail - структура данных, используемая для работы с деталью (объектом) детского конструктора. Является составной из компонентов.; \


<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")
 
* Interface - класс, отвечающий за отображение блоков интерфейса и их функционирование \


<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")

    4.  Формат хранения файла

	Был выбран формат файла описания геометрии OBJ (Wavefront object) — это разработка Wavefront Technologies для анимационного пакета Advanced Visualizer, потому что он является открытым и был принят другими разработчиками приложений 3D графики. Он может быть экспортирован/импортирован во многих программах, связанных с многомерным моделированием. Основная причина выбора - общепринятый формат.

	В файле формата .obj хранятся данные вершин, элементы, кривые произвольной формы, связь между поверхностями свободной формы. В рамках курсового проекта были использованы следующие данные: 

	• геометрические вершины (v); 

	• вершины нормалей (vn);

	• грани (f). 

В очень сложных по детализации файлах формата obj типов данных намного больше, их насчитывается больше 30 разных видов. 

Формат записи данных в файл можно увидеть на рисунке 1.3.1.



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")


_Рис. 1.3.1. Хранение данных в файлах формата OBJ._



    5.  Оформление итогового изображения

	Требование к итоговому изображению:



* Хорошая детализация изображения: отсутствие «рваных пикселей»;
* Правильное отображение световых столбов.

    В связи с установленными требованиями к изображению было принято решение установить разрешение полотна **600 х 600 пикселей**. Данное разрешение было установлено с целью снижения затрат по времени на рендер изображения и отрисовку световых столбов.


    Итоговое изображение продемонстрировано на рисунке 3.4.1.


    

<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")



    _Рис. 3.4.1: Пример работы программы_

    6.   Пользовательский интерфейс.

	Программа имеет русскоязычный интерфейс, организованный в виде набора виджетов, позволяющих пользователю после запуска программы выбрать объекты (детали детского компьютера) и выполнять действия с ними: \
- Добавлять / удалять на холсте

- Перемещать в пространстве  \
- Поворачивать и поворачивает

После запуска программы перед пользователем открывается пустой холст и интерфейс для добавления / удаления / изменения деталей детского конструктора,  см. на рисунке 3.5.1.



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.png "image_tooltip")


_Рис. 3.5.1: Стартовое изображение программы_

	Интерфейс разбит на 4 блока по типу взаимодействия с полотном, см. рисунок 3.5.1:



1. Блок «Деталь» отвечает за выбор из представленных объектов для отрисовки. 
    1. Функциональная клавиша “Добавить” -> Добавить элемент из выбранных в 1.
    2. Функциональная клавиша “Удалить” -> Удалить элемент из выбранных в 2.
2. Блок «Добавленные» отвечает за выбор из отрисованных объектов для операций над ними.
    3. Находится список с возможностью выбора элемента по клику на него
3. Блок «Перемещение» отвечает за перемещение выбранной детали в блоке 2.
    4. Функциональная клавиша “Вверх” -> Переместить элемент из выбранных в 1 вверх.
    5. Функциональная клавиша “Влево” -> Переместить элемент из выбранных в 1 влево.
    6. Функциональная клавиша “Вправо” -> Переместить элемент из выбранных в 1 вправо.
    7. Функциональная клавиша “Вниз” -> Переместить элемент из выбранных в 1 вниз.
4. Блок «Поворот» за поворот выбранной детали в блоке 2.
    8. Выпадающий списка -> Выбор оси поворота (x, y, z). Деталь при вращении относительно оси воспринимается, как точка - ее геометрический центр.
    9. Поле ввода -> Ввод угла поворота вокруг оси с клавиатуры

Доступ ко всем функциям и настройкам осуществляется непосредственно через компоненты основного окна программы. \


<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image15.png "image_tooltip")


_Рис. 3.5.1: Пример уведомления об ошибке_

 \
Пользователь получает оповещения при невозможности выполнить запрашиваемое действие, см. Рис 3.7.1


# Заключение.

	Разработанный программный комплекс отвечает всем предъявляемым к нему требованиям и обеспечивает возможность моделирования световых столбов. Для получения наглядных характеристик алгоритмов необходимо провести исследования на различных наборах данных. Из понимания работы алгоритмов мы можем предположить, что алгоритм z-буфера покажет себя с лучшей стороны скоростью отрисовки сцены, но он не характеризуется реалистичностью синтезированного изображения из-за отсутствия таких эффектов, как освещённость, отражение, преломление и т.д. Сымитировать подобные эффекты возможно, накладывая на объекты заранее просчитанные текстуры освещённости, что в совокупности с эффективными алгоритмами оптимизации по быстродействию приближает изображение к реальности. 


# 


# 
    Список использованной литературы



1. Роджерс Д., Алгоритмические основы машинной графики: пер. с англ.— М.: Мир, 1989.— 512 с.: ил.
2. Марк Пилгрим, Dive into Python, 2017.
3. Steven F. Lott , Dusty Phillips, Python Object-Oriented Programming - Fourth Edition
4. Проблемы трассировки лучей – из будущего в реальное время. [Электронный ресурс]. – Режим доступа: https://nvworld.ru/articles/ray-tracing/3/ 
5. Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж., [Приёмы объектно-ориентированного проектирования. Паттерны проектирования.](http://vk.com/doc5051584_136835430?hash=6dc303827c81f0a4f2&dl=49089454d971962899) – СПб: Питер, 2001. – 368 с.: ил. (Серия «Библиотека программиста») 
6. [Particle Systems](http://homepages.inf.ed.ac.uk/tkomura/cav/presentation8.pdf). [Электронный ресурс]. – Режим доступа: [http://homepages.inf.ed.ac.uk/tkomura](http://homepages.inf.ed.ac.uk/tkomura) 
7. А.Н.Романюк, М.В.Куринный, АЛГОРИТМЫ ПОСТРОЕНИЯ ТЕНЕЙ